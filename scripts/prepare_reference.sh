#!/usr/bin/env bash
set -euo pipefail

# scripts/prepare_references.sh
# Downloads one-or-more reference FASTA URLs (or uses local paths if passed),
# unpacks them, creates samtools faidx, bwa index, and Picard/GATK sequence dictionary,
# and writes ref_manifest.yaml (absolute paths) to the project root.
#
# Usage:
#   ./scripts/prepare_references.sh                # use built-in Ensembl release-115 URLs (chr15 + full)
#   ./scripts/prepare_references.sh <url_or_path>  # prepare one reference
#   ./scripts/prepare_references.sh a.fa b.fa      # prepare multiple local files
#
# Output:
#   reference/                     # contains downloaded .fa and index files
#   ref_manifest.yaml              # YAML manifest in project root with absolute paths

# Default Ensembl release-115 URLs
DEFAULT_URLS=(
  "https://ftp.ensembl.org/pub/release-115/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.primary_assembly.fa.gz"
  "https://ftp.ensembl.org/pub/release-115/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.chromosome.15.fa.gz"
)

OUTDIR=${1:-reference}
# If first arg appears to be a path and more args follow, we'll treat all args as files/URLs
# But to keep interface simple: if positional args >1 then they are the refs; otherwise use defaults.
# We'll detect if "$OUTDIR" is actually a URL/file when more than one arg given.
ARGS=("$@")

# If no args -> use defaults; if args provided -> use them as refs (not treat first as outdir)
if [ $# -eq 0 ]; then
  REFS=("${DEFAULT_URLS[@]}")
  OUTDIR="reference"
else
  # If the user passed exactly one arg and it looks like a directory (ends with / or exists as dir),
  # treat it as OUTDIR. To avoid ambiguity, allow both styles: if first arg is an existing dir, use it as outdir.
  if [ $# -ge 1 ] && [ -d "${ARGS[0]}" ] && [ "$#" -ge 2 ]; then
    OUTDIR="${ARGS[0]}"
    REFS=("${ARGS[@]:1}")
  else
    # All args are references (URLs or local paths)
    REFS=("${ARGS[@]}")
    OUTDIR="reference"
  fi
fi

mkdir -p "$OUTDIR"
MANIFEST_FILE="ref_manifest.yaml"
# Start fresh manifest
echo "# Reference manifest generated by scripts/prepare_references.sh" > "$MANIFEST_FILE"

echo "Preparing references in directory: $OUTDIR"
echo

for REF_SRC in "${REFS[@]}"; do
  echo "==== Processing: $REF_SRC ===="

  # Determine filename: if URL, derive basename; if local path, use basename
  BASENAME=$(basename "$REF_SRC")
  # remove .gz if present for target name
  if [[ "$BASENAME" == *.gz ]]; then
    BASENAME="${BASENAME%.gz}"
  fi

  TARGET_PATH="${OUTDIR}/${BASENAME}"
  TARGET_PATH_NO_EXT="${TARGET_PATH%.*}"   # remove last extension (e.g. .fa or .fna)
  # Download or copy
  if [[ "$REF_SRC" =~ ^https?:// || "$REF_SRC" =~ ^ftp:// ]]; then
    # if remote URL
    if [ -f "$TARGET_PATH" ]; then
      echo "  - Found existing file $TARGET_PATH, skipping download."
    else
      echo "  - Downloading $REF_SRC → $TARGET_PATH.gz"
      wget -c -O "${TARGET_PATH}.gz" "$REF_SRC"
      echo "  - Uncompressing ${TARGET_PATH}.gz"
      gunzip -f "${TARGET_PATH}.gz"
    fi
  else
    # local path
    if [ ! -f "$REF_SRC" ]; then
      echo "ERROR: local file not found: $REF_SRC"
      exit 1
    fi
    echo "  - Copying local file $REF_SRC → $TARGET_PATH"
    cp -v "$REF_SRC" "$TARGET_PATH"
  fi

  # Ensure file exists
  if [ ! -f "$TARGET_PATH" ]; then
    echo "ERROR: expected reference file not found at $TARGET_PATH"
    exit 1
  fi

  # Normalize filename variable for commands
  REF_ABS=$(readlink -f "$TARGET_PATH")
  REF_ROOT="${REF_ABS%.*}"   # strip final extension (e.g. .fa)
  echo "  - Absolute path: $REF_ABS"

  # 1) samtools faidx
  if command -v samtools >/dev/null 2>&1; then
    echo "  - Running: samtools faidx $REF_ABS"
    samtools faidx "$REF_ABS"
  else
    echo "  - WARNING: samtools not found, skipping faidx."
  fi

  # 2) bwa index
  if command -v bwa >/dev/null 2>&1; then
    echo "  - Running: bwa index $REF_ABS (this may take a while for large refs)"
    bwa index "$REF_ABS"
  else
    echo "  - WARNING: bwa not found, skipping bwa index."
  fi

  # 3) Picard/GATK CreateSequenceDictionary -> REF_ROOT.dict
  if command -v picard >/dev/null 2>&1; then
    echo "  - Running: picard CreateSequenceDictionary R=$REF_ABS O=${REF_ROOT}.dict"
    picard CreateSequenceDictionary R="$REF_ABS" O="${REF_ROOT}.dict"
  elif command -v gatk >/dev/null 2>&1; then
    echo "  - Running: gatk CreateSequenceDictionary -R $REF_ABS -O ${REF_ROOT}.dict"
    gatk CreateSequenceDictionary -R "$REF_ABS" -O "${REF_ROOT}.dict"
  else
    echo "  - WARNING: Neither picard nor gatk found; skipping .dict creation."
  fi

  # 4) Report what was created
  echo "  - Produced (if commands available):"
  echo "      fasta: $REF_ABS"
  echo "      fai: ${REF_ABS}.fai"
  echo "      dict: ${REF_ROOT}.dict"
  echo "      bwa index: ${REF_ABS}.* (bwt etc.)"

  # Append entry to manifest (absolute paths)
  echo "" >> "$MANIFEST_FILE"
  echo "# entry for ${BASENAME}" >> "$MANIFEST_FILE"
  echo "name: ${BASENAME}" >> "$MANIFEST_FILE"
  echo "fasta: ${REF_ABS}" >> "$MANIFEST_FILE"
  echo "fai: ${REF_ABS}.fai" >> "$MANIFEST_FILE"
  echo "dict: ${REF_ROOT}.dict" >> "$MANIFEST_FILE"
done

echo
echo "WROTE: $(readlink -f "$MANIFEST_FILE")"
echo "Reference preparation complete."
